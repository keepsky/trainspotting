# Experiments with SMTPlan+

Some very basic attempts at seeing how 
[SMTPlan+](http://kcl-planning.github.io/SMTPlan/) 
([github](https://github.com/KCL-Planning/SMTPlan)) 
would be able to cope with the kind of railway simulation done in 
[`rolling` and `railperfcheck`](https://luteberget.github.io/rollingdocs/).

## The car example

The car example used in the SMTPlan+ benchmarks
seems similar to the simplest possible calculation of 

The car example in the form given in the SMTPlan+ benchmark has 
the following issues:

* Although the PDDL+ input files specify that total time should be minimized, this does
  not seem to be included in the SMT encoding, considering the following output and also
  a quick look at the code
  ```
  $ time SMTPlan car_domain_nodrag.pddl car_prob01.pddl
  0.0:	(accelerate) [0.0]
  1.0:	(decelerate) [0.0]
  31.0:	(decelerate) [0.0]
  32.0:	(stop) [0.0]
  
  real	0m0.031s
  user	0m0.024s
  sys	0m0.007s
  ```
* Since each vehicle's change in action (acceleration, braking, coasting) would need to be 
  represented by a happening in the PDDL+ model, the number of steps for any realistic
  case would need to handle at least 100 steps. SMTPlan+ running time seems to increase
  rapidly with increasing maximum number of possible happening, and quickly puts it out of 
  the "agile verification" use case at around 20 to 30 happenings.
  Increasing the number of happenings in the encoding seems to affect the result, even though only 4 happenings seem to be used. This may be caused by the lack of optimization constraints. 
  ```
  $ time SMTPlan car_domain_nodrag.pddl car_prob01.pddl -v -l 10
  Grounded:	0.001255 seconds
  Algebra:	0.003021 seconds
  Encoded 10:	0.008841 seconds
  12.0:	(accelerate) [0.0]
  14.0:	(decelerate) [0.0]
  28.0:	(decelerate) [0.0]
  30.0:	(stop) [0.0]
  Solved 10:	0.244268 seconds
  Total time:	0.261552 seconds
  ```
  ```
  Grounded:	0.001273 seconds
  Algebra:	0.002686 seconds
  Encoded 20:	0.013745 seconds
  32.0:	(accelerate) [0.0]
  34.0:	(decelerate) [0.0]
  48.0:	(decelerate) [0.0]
  50.0:	(stop) [0.0]
  Solved 20:	5.633186 seconds
  Total time:	5.655070 seconds
  ```
  ```
  Grounded:	0.001274 seconds
  Algebra:	0.002652 seconds
  Encoded 30:	0.017595 seconds
  39.044921875:	(accelerate) [0.0]
  44.466796875:	(decelerate) [0.0]
  44.5780639648?:	(decelerate) [0.0]
  49.9999389648?:	(stop) [0.0]
  Solved 30:	45.368668 seconds
  Total time:	45.394287 seconds
  ```
* Instances generated by SMTPlan+ seem to be solvable by Z3. Which may indicate that
  our approach for encoding to Z3, which return `unknown`, does something odd.
* Setting a tighter bound on the total time closer to the known optimum seems
  to drastically increase the rate of running time increase when increasing the happening bound.
  Modifying the original car example by setting the running time constraint to be less than 11.0 s gives the following running times for increasing number of steps:
  ```
  6 steps: 0.213 s
  7 steps: 2.920 s
  8 steps: > 60 s
  ```
